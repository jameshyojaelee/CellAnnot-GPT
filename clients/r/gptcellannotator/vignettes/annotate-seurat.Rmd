---
title: "Annotate Seurat Clusters with GPT Cell Annotator"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Annotate Seurat Clusters with GPT Cell Annotator}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

# Overview

`gptcellannotator` provides an end-to-end bridge from Seurat marker discovery to
the GPT Cell Annotator backend. This vignette walks through the recommended
pipeline: preparing marker tables, calling the API, applying validation
guardrails, and visualising results on a UMAP embedding.

The package defaults to HTTPS calls against the FastAPI service but can fall
back to the Python CLI (`gca annotate`) when credentials or connectivity are
unavailable. All examples below assume access to the REST API. The offline CLI
workflow is covered at the end.

# Setup

```{r setup, message=FALSE}
library(gptcellannotator)
library(Seurat)
library(tibble)
```

Configure the base URL and API key once per session. Environment variables
(`GPTCA_BASE_URL`, `GPTCA_API_KEY`) take precedence, but explicit configuration
is clearer in reproducible scripts.

```{r}
cfg <- gptca_config(
  base_url = "https://api.gpt-cell-annotator.org",
  timeout = 60,
  retry_max = 3
)
gptca_config_set(cfg)
```

# Load markers

Start with a Seurat object that has undergone clustering. Here we load the demo
PBMC object distributed with Seurat, then compute positive markers per cluster via
`FindAllMarkers`. The function returns a long data frame with columns `gene`,
`cluster`, `avg_log2FC`, and more.

```{r markers, eval=FALSE}
pbmc <- readRDS("path/to/pbmc.rds")
markers <- FindAllMarkers(pbmc, only.pos = TRUE, logfc.threshold = 0.25)
```

The first rows look like:

```{r markers-head, eval=FALSE}
markers %>% as_tibble() %>% dplyr::group_by(cluster) %>% dplyr::slice_head(n = 3)
```

# Submit markers for annotation

`gptca_annotate_seurat()` handles conversion to the backend payload, including
limiting the top markers per cluster and sorting by `avg_log2FC`.

```{r annotate, eval=FALSE}
annotations <- gptca_annotate_seurat(
  pbmc,
  markers = markers,
  species = "Homo sapiens",
  tissue = "Peripheral blood",
  return_validated = TRUE,
  top_n = 25
)
```

The result is a `gptca_annotation` object with convenient accessors:

```{r result-structure, eval=FALSE}
annotations$clusters
annotations$summary
```

- `clusters` – tidy tibble with per-cluster labels, ontology IDs, validation
  status, and collected warnings.
- `summary` – dataset-level support metrics from the validation report.
- `raw` – full JSON payload if you need access to every nested field.

# Merge results into Seurat metadata

Annotator outputs should become part of your object metadata so downstream plots
and differential analyses can use the curated labels. `gptca_add_metadata()`
adds a set of columns (`gptca_label`, `gptca_confidence`, `gptca_status`,
`gptca_warnings`) keyed by the existing clustering column.

```{r metadata, eval=FALSE}
pbmc <- gptca_add_metadata(pbmc, annotations)
head(pbmc@meta.data[, c("seurat_clusters", "gptca_label", "gptca_status")])
```

Clusters flagged during validation will have `gptca_status` set to `"flagged"`
or `"unknown"`, and the warnings column retains the backend rationale.

# Visualise on UMAP

`gptca_plot_umap()` renders a ggplot built from the stored embeddings. Flagged
clusters are outlined in black to emphasise groups requiring manual review.

```{r plot, eval=FALSE}
gptca_plot_umap(pbmc)
```

Because the plot is built with `ggplot2` you can further customise scales,
themes, or overlays using standard syntax.

# CLI fallback workflow

If the REST API is unreachable, the package can shell out to `gca annotate`
instead. Install the CLI (`pip install gpt-cell-annotator`), ensure the `gca`
binary is on your `PATH`, and toggle offline mode in the config.

```{r cli-fallback, eval=FALSE}
offline_cfg <- gptca_config(offline = TRUE, cli_path = Sys.which("gca"))
annotations <- gptca_annotate_markers(
  markers,
  species = "Homo sapiens",
  config = offline_cfg
)
```

The CLI path is automatically discovered from `GPTCA_CLI_PATH` or the system
`PATH`. Validation guardrails are still executed because the Python CLI ships
with the marker database assets.

# Troubleshooting

- **401/403 errors** – check the API key and whether the backend expects custom
  headers.
- **429 rate limits** – reduce batch sizes or introduce throttling. The package
  will automatically retry transient 429/5xx errors with exponential backoff.
- **Validation disagreements** – inspect `annotations$clusters$validation` for
  missing markers or contradictory evidence. You can also access the raw JSON
  via `annotations$raw`.

For more recipes and automation tips, visit the pkgdown site once published or
open an issue on GitHub.
